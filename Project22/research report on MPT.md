# research report on MPT

## Merkle Patricia Tree简介

Merkle Patricia Tree（也称为Merkle Patricia Trie）是一种数据结构，融合了Merkle tree和前缀树两种树结构的优点，并进行改良，是以太坊中用于组织和管理账户数据、生成交易集合哈希的重要数据结构。

MPT树的作用如下：

1. 存储任意长度的key-value键值对数据，符合以太坊的state模型；
2. 提供了一种快速计算所维护数据集哈希标识的机制；
3. 提供了快速状态回滚的机制；
4. 提供了一种称为默克尔证明的证明方法，用于轻节点的扩展，实现简单支付验证。

MPT结合了Radix trie和Merkle两种树结构的特点和优势，因此在介绍MPT之前，我们首先简要介绍了这两种树结构的特点,Merkle树在Project5中已经介绍并且实现过，因此在这里不多作介绍。

## Trie树

Trie树，又称**前缀树或字典树**，是一种有序树，用于保存关联数组。其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定 。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而 根节点对应空字符串。

一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。实际上trie每个节点是一个确定长度的数组，数组中每个节点的值是一个指向子节点的指针，最后有个标志域，标识这个位置为止是否是一个完整的字符串.

常见的用来存英文单词的trie每个节点是一个长度为27的指针数组，index0-25代表a-z字符，26为标志域。

###### 优势：

相比于哈希表，使用前缀树来进行查询拥有共同前缀key的数据时十分高效，例如在字典中查找前缀为pre的单词，对于哈希表来说，需要遍历整个表，时间效率为O(n)，然而对于前缀树来说，只需要在树中找到前缀为pre的节点，且遍历以这个节点为根节点的子树即可。

但是对于最差的情况（前缀为空串)，时间效率为O(n),仍然需要遍历整棵树，此时效率与哈希表相同。

相比于哈希表，在前缀树不会存在哈希冲突的问题。

###### 劣势：

- 直接查找效率低下 前缀树的查找效率是O(m)，m为所查找节点的key长度，而哈希表的查找效率为O(1)。且一次查找会有m次IO开销，相比于直接查找，无论是速率、还是对磁盘的压力都比较大。
- 可能会造成空间浪费 当存在一个节点，其key值内容很长（如一串很长的字符串），当树中没有与他相同前缀的分支时，为了存储该节点，需要创建许多非叶子节点来构建根节点到该节点间的路径，造成了存储空间的浪费。
## MPT
### MPT树的基本操作
1. Get
一次Get操作的过程如下：

将需要查找Key的Raw编码转换成Hex编码，得到的内容称之为搜索路径；
从根节点开始搜寻与搜索路径内容一致的路径；
若当前节点为叶子节点，存储的内容是数据项的内容，且搜索路径的内容与叶子节点的key一致，则表示找到该节点；反之则表示该节点在树中不存在。
若当前节点为扩展节点，且存储的内容是哈希索引，则利用哈希索引从数据库中加载该节点，再将搜索路径作为参数，对新解析出来的节点递归地调用查找函数。
若当前节点为扩展节点，存储的内容是另外一个节点的引用，且当前节点的key是搜索路径的前缀，则将搜索路径减去当前节点的key，将剩余的搜索路径作为参数，对其子节点递归地调用查找函数；若当前节点的key不是搜索路径的前缀，表示该节点在树中不存在。
若当前节点为分支节点，若搜索路径为空，则返回分支节点的存储内容；反之利用搜索路径的第一个字节选择分支节点的孩子节点，将剩余的搜索路径作为参数递归地调用查找函数。
2. Insert
插入操作也是基于查找过程完成的，一个插入过程为：

根据Get操作的查找步骤，首先找到与新插入节点拥有最长相同路径前缀的节点，记为Node；
若该Node为分支节点：
剩余的搜索路径不为空，则将新节点作为一个叶子节点插入到对应的孩子列表中；
剩余的搜索路径为空（完全匹配），则将新节点的内容存储在分支节点的第17个孩子节点项中（Value）；
若该节点为叶子／扩展节点：
剩余的搜索路径与当前节点的key一致，则把当前节点Val更新即可；
剩余的搜索路径与当前节点的key不完全一致，则将叶子／扩展节点的孩子节点替换成分支节点，将新节点与当前节点key的共同前缀作为当前节点的key，将新节点与当前节点的孩子节点作为两个孩子插入到分支节点的孩子列表中，同时当前节点转换成了一个扩展节点（若新节点与当前节点没有共同前缀，则直接用生成的分支节点替换当前节点）；
若插入成功，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在；
3. Delete
删除操作与插入操作类似，都需要借助查找过程完成，一次删除过程为：

根据Get操作的查找步骤，找到与需要插入的节点拥有最长相同路径前缀的节点，记为Node；
若Node为叶子／扩展节点：
若剩余的搜索路径与node的Key完全一致，则将整个node删除；
若剩余的搜索路径与node的key不匹配，则表示需要删除的节点不存于树中，删除失败；
若node的key是剩余搜索路径的前缀，则对该节点的Val做递归的删除调用；
若Node为分支节点：
删除孩子列表中相应下标标志的节点；
若Node的孩子个数只剩下一个，那么将分支节点替换成一个叶子／扩展节点；
若删除成功，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在；
4. Update
更新操作就是Insert与Delete的结合。当用户调用Update函数时，若value不为空，则隐式地转为调用Insert；若value为空，则隐式地转为调用Delete，故在此不再赘述。

5. Commit
Commit函数提供将内存中的MPT数据持久化到数据库的功能。在第一章中我们提到的MPT具有快速计算所维护数据集哈希标识以快速状态回滚的能力，也都是在该函数中实现的。

在Commit完成后，所有变脏的树节点会重新进行哈希计算，并且将新内容写入数据库；最终新的根节点哈希将被作为MPT的最新状态被返回。
