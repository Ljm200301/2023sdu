 # <center>  Project2 </center>

# 实现方式
Rho方法是一种基于哈希链的碰撞查找算法，通常用于对哈希函数进行攻击。该算法通过维护两个不同的哈希链来查找碰撞。  
Rho方法的基本思路是选择一个随机数作为起点，然后使用哈希函数对其进行一系列的迭代计算，每次计算时都将前一次的结果作为输入，得到一个新的输出。这样，就得到了一个哈希链。为了找到碰撞，需要维护两个不同的哈希链，并不断地对它们进行迭代计算，直到找到两个相同的输出。  
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/rho.png">
</div>

在具体实现的过程中，使用了OpenSSL库提供的EVP_MD_CTX结构体和EVP_Digest函数来进行SM3哈希计算。**主要寻找碰撞的过程如下：**  
- 定义了四个长度为32的unsigned char数组out1、out2、out3和out4，用于存储哈希函数的输出结果。  
- 使用EVP_Digest函数对data数组进行SM3哈希计算，将结果存储在out1数组中。  
- 使用EVP_Digest函数对out1数组进行SM3哈希计算，将结果存储在out2数组中。
- 之后进入寻找碰撞过程：
  - 使用EVP_Digest函数对out1数组进行SM3哈希计算，将结果存储在out3数组中。  
  -  使用EVP_Digest函数对out2数组进行SM3哈希计算，将结果存储在out4数组中。  
  - 从out3和out4数组中取出COLLISION_BYTE个字节作为哈希函数输出结果的前缀，如果这两个前缀相同，则表示找到了碰撞，输出碰撞的结果并跳出循环。  
  - 将out3数组的内容复制到out1数组中，将out4数组的内容复制到out2数组中。  
# 实现效果
**找到24bit的碰撞，如下图所示，最多可找到40bit的碰撞。**
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/rho_method.png">
</div>
寻找到24bit碰撞的时间经多次测试为2s左右，寻找40bit碰撞的时间约3分钟.


 # <center>  Project5 </center>

# 实现要求
• Construct a Merkle tree with 10w leaf nodes

• Build inclusion proof for specified element

• Build exclusion proof for specified element

# 实现方式
利用openssl1.1实现，在merkle_tree.h头文件中定义了几个类：merkle_leaf类表示Merkle树中的叶节点，Node类表示Merkle树中的内部节点，merkle_tree类表示Merkle树数据结构。

以下是对几个重要函数的解释说明:

`void merkle_tree::add(uint32_t value)`：此函数将新的叶节点添加到Merkle树中，其整数值为value。它创建一个新的Merkle叶节点并将其附加到叶节点列表中。如果树中的节点数超过当前级别的最大节点数，则增加树的级别。

`void merkle_tree::update()`：此函数通过计算树的内部节点来更新Merkle树。它首先清除内部节点列表并将其调整为适当的大小。然后为每个叶节点创建Merkle节点，并将其存储在内部节点列表的适当位置。然后迭代地组合节点以计算树的内部节点。

`uint64_t merkle_tree::sibling_node(uint64_t index)`：此函数返回给定索引的节点的兄弟节点的索引。

`std::vector<HASH_TYPE> merkle_tree::make_proof()`：此函数返回Merkle树根哈希值，其可用作整个树完整性的证明。

`bool is_internal_node_equal(Node* in1, Node* in2)`：此函数比较两个Merkle树节点的哈希值，如果它们相等，则返回true。

`uint64_t merkle_tree::get_num_nodes()`：此函数返回Merkle树中的节点总数。

`bool merkle_tree::inclusion_proof(uint64_t index, merkle_leaf* in)`：此函数检查给定索引处的叶节点的Merkle证明是否有效。如果需要，它首先更新树，然后从叶节点到根节点遍历树，计算沿途节点的哈希值。然后比较计算出的根哈希值与预期的根哈希值，如果相等，则返回true。
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/merkle_tree.png">
</div>
bool merkle_tree::consistency_proof(merkle_tree* old_tree)：此函数检查新的Merkle树是否与旧的Merkle树一致。如果需要，它首先更新两个树，然后计算旧树中与新树相同的最后一个节点的索引。然后验证旧树和新树在该节点处的哈希值是否匹配，并验证两个树在根节点处的哈希值是否匹配。如果两个检查都通过，则该函数返回true。

# 实现效果
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/merkle_tree.png">
</div>
可以看到构建10w个叶节点的Merkle树成功，用时42.3013ms

inclusion proof成功（此处以节点01234为例展示效果），总计用时98.5455ms

exclusion proof成功，用时17.538ms

 # <center>  Project10 </center>

# report on the application of this deduce technique in Ethereum with ECDSA
## ECDSA简介
ECDSA（Elliptic Curve Digital Signature Algorithm，椭圆曲线数字签名算法）是一种基于椭圆曲线密码学的数字签名算法。$ECDSA$ 的安全性基于椭圆曲线离散对数问题，与普通的离散对数问题（DLP）和大数分解问题（IFP）不同，椭圆曲线离散对数问题没有亚指数时间的解决方法。因此椭圆曲线密码的单位比特强度要高于其他公钥体制。   
假设私钥为 $d$，公钥为 $Q$，消息的哈希值为 $H$，随机数为 $k$， $k$ 的逆元为 $k^{-1}$，椭圆曲线参数为 $a$、 $b$ 和 $p$。  
签名过程：  
（1）计算 $kG$ 的 $x$ 坐标，即 $r = x(kG) \bmod p$，其中 $G$ 是椭圆曲线上的基点。  
（2）计算 $s = k^{-1}(H + dr) \bmod p$。  
（3）得到签名 $(r, s)$。  
验证过程：  
（1）计算 $w = s^{-1} \bmod p$。  
（2）计算 $u_1 = Hw \bmod p$ 和 $u_2 = rw \bmod p$。  
（3）计算点 $P = u_1G + u_2Q$。  
（4）如果 $P$ 的 $x$ 坐标等于 $r$，则认为签名是有效的，否则认为签名是无效的。  
## Recover public key from signature
### 恢复方法
从签名中恢复公钥是区块链系统（例如以太坊）中的一种有用技术，其中使用 ECDSA 签名对交易进行签名。在传统的 ECDSA 签名中，公钥不包含在签名的消息中，这意味着需要使用签名和消息哈希来恢复公钥。要从 ECDSA 签名中恢复公钥，可以执行以下步骤：  
从签名 $(r, s)$ 中计算出 $r$ 和 $s$ 的值。  
计算签名的消息哈希 $H$。
使用 $r$、 $s$ 和 $H$ 的值来计算公钥 $Q$ 的值。这可以使用以下公式完成：

$$
\begin{align*}
Q &= r^{-1}(sP-eG)\\
&=r^{-1}(k^{-1}(e+dr)kG-eG)\\
&=r^{-1}((e+dr)G-eG)\\
&=dG
\end{align*}
$$

其中， $G$ 是椭圆曲线的基点， $Q_a$ 是用于签名消息的私钥关联的公钥， $\cdot$ 表示曲线上的点乘法。  
### 应用
在区块链中，用户交易地址为公钥哈希值的编码，在验证交易时，需要对签名和地址进行验证。由于无法直接从交易地址中恢复出公钥，为验证交易的合法性，一般将公钥附加在交易中，然而一个区块可能包括成千个交易，会增加较大的存储开销。以太坊中通过从签名中恢复公钥进而对交易进行验证，该方法可节省一定的存储空间。  
一旦恢复了公钥 $Q$，它可以用于验证签名并确保签名的消息的真实性和完整性，有以下几方面的好处：  
**1.节省存储空间。只需利用签名即可恢复出公钥,无需额外存储公钥,可大大节省公钥的存储开销，从而提高区块链网络的整体性能。**   
**2.交易地址可验证。通过签名可快速恢复出公钥,进而恢复交易发送方的交易地址,从而对交易地址进行合法性验证。**    
总之，从签名中恢复公钥和发送不附带公钥的交易是可以提高区块链系统效率和安全性的重要技术。

 # <center>  Project11 </center>
# 实现方式：
椭圆曲线上点的加法运算：    
若 $P \neq Q$ ， $\lambda = ((y_2 - y_1) \cdot (x_2 - x_1)^{-1}) \mod p$ ， $x_3 = (\lambda^2 - x_1 - x_2) \mod p$ ， $y_3 = (\lambda \cdot (x_1 - x_3) - y_1) \mod p$ 。  
若 $P = Q$ ， $\lambda = ((3 \cdot x_1^2 + a) \cdot (2 \cdot y_1)^{-1}) \mod p$ ， $x_3 = (\lambda^2 - 2 \cdot x_1) \mod p$ ， $y_3 = (\lambda \cdot (x_1 - x_3) - y_1) \mod p$ 
  。  
椭圆曲线上点的标量倍乘：  
将 $k$ 表示为二进制形式，从高位到低位依次处理，若第 $i$ 位为1，则将点 $P$ 与 $2^{i-1}$ 倍点相加：  
$$Q = kP = \sum_{i=0}^{n-1} k_i2^iP$$  
其中， $k_i$ 为 $k$ 的二进制表示的第 $i$ 位， $n$ 为 $k$ 的二进制表示的位数。


## SM2签名
SM2签名算法：
（1）生成私钥和公钥：选择一个随机数 $da$ 作为私钥，计算公钥 $Pa = da \cdot G$ ，其中 $G$ 为椭圆曲线上的基点。  
（2）签名：对于消息 $m$ ，首先计算 $m_1 = Za || m$ ，其中 $Za$ 为 $m_1$ 的哈希值。选择一个随机数 $k$ ，并计算椭圆曲线上的点 $(x_1, y_1) = k \cdot G$ 。计算 $r = (e + x_1) \mod n$ ，其中 $e$ 为 $m_1$ 的哈希值， $n$ 为曲线上点的个数。若 $r=0$ 或 $r+k=n$ ，则重新选择 $k$ 。计算 $s = ((1 + da)^{-1} \cdot (k - r \cdot da)) \mod n$ 。若 $s=0$ ，则重新选择 $k$ 。最终的签名为 $(r, s)$ 。  
（3）验证：对于签名 $(r, s)$ 和消息 $m$ ，首先计算 $m_1 = Za || m$ ，其中 $Za$ 为 $m_1$ 的哈希值。计算 $t = (r + s) \mod n$ 。计算椭圆曲线上的点 $(x_1, y_1) = s \cdot G + t \cdot Pa $。计算 $e' = Hash(Za || m)$ ，计算 $R' = (e' + x_1) \mod n$ 。若 $R'=r$ ，则签名有效，否则无效。  
其中， $Hash$ 函数使用了SM3哈希算法。
## SM2加密
### SM2加密过程：

输入：明文消息  $m$  

输出：密文分量 $c_1$ 、 $c_2$ 和 $c_3$ 

将明文消息 $m$ 转换为二进制字符串 $m_{bin}$ 。

用 $0$ 填充 $m_{bin}$ ，使其长度为 $4$ 的倍数。

生成一个随机数 $k$ ，并计算椭圆曲线上的点 $(x_1, y_1) = k \cdot G$ ，其中 $G$ 为椭圆曲线上的基点。

计算公钥 $P_a = d_a \cdot G$ ，其中 $d_a$ 为私钥。

计算椭圆曲线上的点 $(x_2, y_2) = k \cdot P_a$ ，将 $(x_2, y_2)$ 转换为二进制字符串 $x_{2bin}$和 $y_{2bin}$  。

调用KDF函数，从 $(x_{2bin} + y_{2bin})$ 生成一个长度为 $4\lceil \frac{|m|}{4} \rceil$ 的二进制字符串 $t$ 。

将 $m_{bin}$ 与 $t$ 进行异或运算，得到密文 $c_2$ 。

计算密文的认证标签 $c_3 = Hash(x_{2bin} + m_{bin} + y_{2bin})$ ，其中 $Hash$ 函数采用了SM3哈希算法。

返回密文分量 $c_1$ 、 $c_2$ 和 $c_3$ ，其中 $c_1$ 为公钥坐标 $(x_1, y_1)$ 的十六进制字符串， $c_2$ 为密文的十六进制字符串， $c_3$ 为认证标签的十六进制字符串。

### SM2解密过程：

输入：密文分量 $c_1$ 、 $c_2$ 和 $c_3$ 

输出：解密后的明文消息 $m$ 

从 $c_1$ 中解析出公钥坐标 $(x_1, y_1)$。 

验证公钥坐标是否在椭圆曲线上。

计算椭圆曲线上的点 $(x_2, y_2) = d_a \cdot (x_1, y_1)$ 。

将 $(x_2, y_2)$ 转换为二进制字符串 $x_{2bin}$ 和 $y_{2bin}$ 。

调用KDF函数，从 $(x_{2bin}+ y_{2bin})$ 生成一个长度为 $4\cdot |c_2|$ (其中 $|c_2|$ 表示 $c_2$ 的长度) 的二进制字符串 $t$ 。

将密文 $c_2$ 与 $t$ 进行异或运算，得到二进制字符串 $m_{bin}$ 。

计算密文的认证标签 $u = Hash(x_{2bin} + m_{bin} + y_{2bin})$ 。

验证 $c_3$ 是否等于 $u$ 。

将 $m_{bin}$ 转换为十六进制字符串，再将其转换为明文消息 $m$ 。

返回明文消息 $m$ 。

其中， $d_a$ 为私钥， $G$ 为椭圆曲线上的基点， $a$ 、 $b$ 和 $p$ 为椭圆曲线的参数。

# 实现效果
### SM2加密
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/SM2_Enc.jpg">
</div>

### SM2签名
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/SM2_Sign.png">
</div>


 # <center>  Project12 </center>


 # <center>  Project13 </center>


 # <center>  Project14 </center>


 # <center>  Project15 </center>


 # <center>  Project16 </center>


 # <center>  Project17 </center>


 # <center>  Project18 </center>


 # <center>  Project19 </center>


 # <center>  Project21 </center>


 # <center>  Project22 </center>

