 # <center>  Project1 </center>

# 实现方式
生日攻击（Birthday Attack）是一种常见的哈希函数攻击方法，其基本原理是利用生日悖论来寻找哈希函数的碰撞。生日悖论是指，在一个房间里面，如果有23个人，那么至少有两个人的生日相同的概率超过一半。这是因为，如果每个人的生日是随机的，那么在23个人中，总共有 $\binom{23}{2} = 253$ 种不同的生日组合，有很大的概率会出现生日相同的情况。  
利用生日悖论来寻找哈希函数的碰撞，具体实现步骤如下：
- 生成一组随机消息，并计算它们的哈希值；
- 将哈希值按照某种方式存储到一个表格中；
- 生成另外一组随机消息，并计算它们的哈希值；
- 检查这些哈希值是否已经在表格中出现过，如果出现过，则找到了哈希函数的碰撞，否则重复步骤2~4，直到找到为止。
在实际应用中，生日攻击的效率取决于哈希值的长度，一般来说，如果哈希值的长度为 $n$ 位，则需要生成大约 $2^{n/2}$ 个随机消息才能达到一定的碰撞概率。

代码中的 Pollard_Rho 函数实现了随机漫步算法来寻找哈希函数的原像。在该函数中，首先生成两个随机数 m1 和 m2，然后用一个循环不断地更新这两个值，直到它们相等，这时就找到了一个环。然后，使用哈希函数将两个值之差作为输入，得到一个新的哈希值，检查这个哈希值是否与目标哈希值（即要寻找原像的哈希值）的前 $Collisionlen$ 位相同，如果相同，则找到了一组碰撞，否则继续循环。这里的 $Collisionlen$ 是一个预设的参数，表示要比较的哈希值的前几位。

在 PreimageAttack 函数中，先生成一个随机数作为要寻找原像的哈希值，然后调用 Pollard_Rho 函数来寻找这个哈希值的原像。如果找到了原像，则输出找到的原像和找到碰撞所用的时间。如果没有找到原像，则继续生成新的随机数进行尝试。  
# 实现效果
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/birthday _attack.png">
</div>


 
 
 # <center>  Project2 </center>

# 实现方式
Rho方法是一种基于哈希链的碰撞查找算法，通常用于对哈希函数进行攻击。该算法通过维护两个不同的哈希链来查找碰撞。  
Rho方法的基本思路是选择一个随机数作为起点，然后使用哈希函数对其进行一系列的迭代计算，每次计算时都将前一次的结果作为输入，得到一个新的输出。这样，就得到了一个哈希链。为了找到碰撞，需要维护两个不同的哈希链，并不断地对它们进行迭代计算，直到找到两个相同的输出。  
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/rho.png">
</div>

在具体实现的过程中，使用了OpenSSL库提供的EVP_MD_CTX结构体和EVP_Digest函数来进行SM3哈希计算。**主要寻找碰撞的过程如下：**  
- 定义了四个长度为32的unsigned char数组out1、out2、out3和out4，用于存储哈希函数的输出结果。  
- 使用EVP_Digest函数对data数组进行SM3哈希计算，将结果存储在out1数组中。  
- 使用EVP_Digest函数对out1数组进行SM3哈希计算，将结果存储在out2数组中。
- 之后进入寻找碰撞过程：
  - 使用EVP_Digest函数对out1数组进行SM3哈希计算，将结果存储在out3数组中。  
  -  使用EVP_Digest函数对out2数组进行SM3哈希计算，将结果存储在out4数组中。  
  - 从out3和out4数组中取出COLLISION_BYTE个字节作为哈希函数输出结果的前缀，如果这两个前缀相同，则表示找到了碰撞，输出碰撞的结果并跳出循环。  
  - 将out3数组的内容复制到out1数组中，将out4数组的内容复制到out2数组中。  
# 实现效果
**找到24bit的碰撞，如下图所示，最多可找到40bit的碰撞。**
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/rho_method.png">
</div>
寻找到24bit碰撞的时间经多次测试为2s左右，寻找40bit碰撞的时间约3分钟.


 # <center>  Project5 </center>

# 实现要求
• Construct a Merkle tree with 10w leaf nodes

• Build inclusion proof for specified element

• Build exclusion proof for specified element

# 实现方式
利用openssl1.1实现，在merkle_tree.h头文件中定义了几个类：merkle_leaf类表示Merkle树中的叶节点，Node类表示Merkle树中的内部节点，merkle_tree类表示Merkle树数据结构。

以下是对几个重要函数的解释说明:

`void merkle_tree::add(uint32_t value)`：此函数将新的叶节点添加到Merkle树中，其整数值为value。它创建一个新的Merkle叶节点并将其附加到叶节点列表中。如果树中的节点数超过当前级别的最大节点数，则增加树的级别。

`void merkle_tree::update()`：此函数通过计算树的内部节点来更新Merkle树。它首先清除内部节点列表并将其调整为适当的大小。然后为每个叶节点创建Merkle节点，并将其存储在内部节点列表的适当位置。然后迭代地组合节点以计算树的内部节点。

`uint64_t merkle_tree::sibling_node(uint64_t index)`：此函数返回给定索引的节点的兄弟节点的索引。

`std::vector<HASH_TYPE> merkle_tree::make_proof()`：此函数返回Merkle树根哈希值，其可用作整个树完整性的证明。

`bool is_internal_node_equal(Node* in1, Node* in2)`：此函数比较两个Merkle树节点的哈希值，如果它们相等，则返回true。

`uint64_t merkle_tree::get_num_nodes()`：此函数返回Merkle树中的节点总数。

`bool merkle_tree::inclusion_proof(uint64_t index, merkle_leaf* in)`：此函数检查给定索引处的叶节点的Merkle证明是否有效。如果需要，它首先更新树，然后从叶节点到根节点遍历树，计算沿途节点的哈希值。然后比较计算出的根哈希值与预期的根哈希值，如果相等，则返回true。
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/merkle_tree.png">
</div>
bool merkle_tree::consistency_proof(merkle_tree* old_tree)：此函数检查新的Merkle树是否与旧的Merkle树一致。如果需要，它首先更新两个树，然后计算旧树中与新树相同的最后一个节点的索引。然后验证旧树和新树在该节点处的哈希值是否匹配，并验证两个树在根节点处的哈希值是否匹配。如果两个检查都通过，则该函数返回true。

# 实现效果
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/merkle_tree.png">
</div>
可以看到构建10w个叶节点的Merkle树成功，用时42.3013ms

inclusion proof成功（此处以节点01234为例展示效果），总计用时98.5455ms

exclusion proof成功，用时17.538ms

 # <center>  Project10 </center>

# report on the application of this deduce technique in Ethereum with ECDSA
## ECDSA简介
ECDSA（Elliptic Curve Digital Signature Algorithm，椭圆曲线数字签名算法）是一种基于椭圆曲线密码学的数字签名算法。$ECDSA$ 的安全性基于椭圆曲线离散对数问题，与普通的离散对数问题（DLP）和大数分解问题（IFP）不同，椭圆曲线离散对数问题没有亚指数时间的解决方法。因此椭圆曲线密码的单位比特强度要高于其他公钥体制。   
假设私钥为 $d$，公钥为 $Q$，消息的哈希值为 $H$，随机数为 $k$， $k$ 的逆元为 $k^{-1}$，椭圆曲线参数为 $a$、 $b$ 和 $p$。  
签名过程：  
（1）计算 $kG$ 的 $x$ 坐标，即 $r = x(kG) \bmod p$，其中 $G$ 是椭圆曲线上的基点。  
（2）计算 $s = k^{-1}(H + dr) \bmod p$。  
（3）得到签名 $(r, s)$。  
验证过程：  
（1）计算 $w = s^{-1} \bmod p$。  
（2）计算 $u_1 = Hw \bmod p$ 和 $u_2 = rw \bmod p$。  
（3）计算点 $P = u_1G + u_2Q$。  
（4）如果 $P$ 的 $x$ 坐标等于 $r$，则认为签名是有效的，否则认为签名是无效的。  
## Recover public key from signature
### 恢复方法
从签名中恢复公钥是区块链系统（例如以太坊）中的一种有用技术，其中使用 ECDSA 签名对交易进行签名。在传统的 ECDSA 签名中，公钥不包含在签名的消息中，这意味着需要使用签名和消息哈希来恢复公钥。要从 ECDSA 签名中恢复公钥，可以执行以下步骤：  
从签名 $(r, s)$ 中计算出 $r$ 和 $s$ 的值。  
计算签名的消息哈希 $H$。
使用 $r$、 $s$ 和 $H$ 的值来计算公钥 $Q$ 的值。这可以使用以下公式完成：

$$
\begin{align*}
Q &= r^{-1}(sP-eG)\\
&=r^{-1}(k^{-1}(e+dr)kG-eG)\\
&=r^{-1}((e+dr)G-eG)\\
&=dG
\end{align*}
$$

其中， $G$ 是椭圆曲线的基点， $Q_a$ 是用于签名消息的私钥关联的公钥， $\cdot$ 表示曲线上的点乘法。  
### 应用
在区块链中，用户交易地址为公钥哈希值的编码，在验证交易时，需要对签名和地址进行验证。由于无法直接从交易地址中恢复出公钥，为验证交易的合法性，一般将公钥附加在交易中，然而一个区块可能包括成千个交易，会增加较大的存储开销。以太坊中通过从签名中恢复公钥进而对交易进行验证，该方法可节省一定的存储空间。  
一旦恢复了公钥 $Q$，它可以用于验证签名并确保签名的消息的真实性和完整性，有以下几方面的好处：  
**1.节省存储空间。只需利用签名即可恢复出公钥,无需额外存储公钥,可大大节省公钥的存储开销，从而提高区块链网络的整体性能。**   
**2.交易地址可验证。通过签名可快速恢复出公钥,进而恢复交易发送方的交易地址,从而对交易地址进行合法性验证。**    
总之，从签名中恢复公钥和发送不附带公钥的交易是可以提高区块链系统效率和安全性的重要技术。

 # <center>  Project11 </center>
# 实现方式：
椭圆曲线上点的加法运算：    
若 $P \neq Q$ ， $\lambda = ((y_2 - y_1) \cdot (x_2 - x_1)^{-1}) \mod p$ ， $x_3 = (\lambda^2 - x_1 - x_2) \mod p$ ， $y_3 = (\lambda \cdot (x_1 - x_3) - y_1) \mod p$ 。  
若 $P = Q$ ， $\lambda = ((3 \cdot x_1^2 + a) \cdot (2 \cdot y_1)^{-1}) \mod p$ ， $x_3 = (\lambda^2 - 2 \cdot x_1) \mod p$ ， $y_3 = (\lambda \cdot (x_1 - x_3) - y_1) \mod p$ 
  。  
椭圆曲线上点的标量倍乘：  
将 $k$ 表示为二进制形式，从高位到低位依次处理，若第 $i$ 位为1，则将点 $P$ 与 $2^{i-1}$ 倍点相加：  
$$Q = kP = \sum_{i=0}^{n-1} k_i2^iP$$  
其中， $k_i$ 为 $k$ 的二进制表示的第 $i$ 位， $n$ 为 $k$ 的二进制表示的位数。


## SM2签名
SM2签名算法：
（1）生成私钥和公钥：选择一个随机数 $da$ 作为私钥，计算公钥 $Pa = da \cdot G$ ，其中 $G$ 为椭圆曲线上的基点。  
（2）签名：对于消息 $m$ ，首先计算 $m_1 = Za || m$ ，其中 $Za$ 为 $m_1$ 的哈希值。选择一个随机数 $k$ ，并计算椭圆曲线上的点 $(x_1, y_1) = k \cdot G$ 。计算 $r = (e + x_1) \mod n$ ，其中 $e$ 为 $m_1$ 的哈希值， $n$ 为曲线上点的个数。若 $r=0$ 或 $r+k=n$ ，则重新选择 $k$ 。计算 $s = ((1 + da)^{-1} \cdot (k - r \cdot da)) \mod n$ 。若 $s=0$ ，则重新选择 $k$ 。最终的签名为 $(r, s)$ 。  
（3）验证：对于签名 $(r, s)$ 和消息 $m$ ，首先计算 $m_1 = Za || m$ ，其中 $Za$ 为 $m_1$ 的哈希值。计算 $t = (r + s) \mod n$ 。计算椭圆曲线上的点 $(x_1, y_1) = s \cdot G + t \cdot Pa $。计算 $e' = Hash(Za || m)$ ，计算 $R' = (e' + x_1) \mod n$ 。若 $R'=r$ ，则签名有效，否则无效。  
其中， $Hash$ 函数使用了SM3哈希算法。
## SM2加密
### SM2加密过程：

输入：明文消息  $m$  

输出：密文分量 $c_1$ 、 $c_2$ 和 $c_3$ 

将明文消息 $m$ 转换为二进制字符串 $m_{bin}$ 。

用 $0$ 填充 $m_{bin}$ ，使其长度为 $4$ 的倍数。

生成一个随机数 $k$ ，并计算椭圆曲线上的点 $(x_1, y_1) = k \cdot G$ ，其中 $G$ 为椭圆曲线上的基点。

计算公钥 $P_a = d_a \cdot G$ ，其中 $d_a$ 为私钥。

计算椭圆曲线上的点 $(x_2, y_2) = k \cdot P_a$ ，将 $(x_2, y_2)$ 转换为二进制字符串 $x_{2bin}$和 $y_{2bin}$  。

调用KDF函数，从 $(x_{2bin} + y_{2bin})$ 生成一个长度为 $4\lceil \frac{|m|}{4} \rceil$ 的二进制字符串 $t$ 。

将 $m_{bin}$ 与 $t$ 进行异或运算，得到密文 $c_2$ 。

计算密文的认证标签 $c_3 = Hash(x_{2bin} + m_{bin} + y_{2bin})$ ，其中 $Hash$ 函数采用了SM3哈希算法。

返回密文分量 $c_1$ 、 $c_2$ 和 $c_3$ ，其中 $c_1$ 为公钥坐标 $(x_1, y_1)$ 的十六进制字符串， $c_2$ 为密文的十六进制字符串， $c_3$ 为认证标签的十六进制字符串。

### SM2解密过程：

输入：密文分量 $c_1$ 、 $c_2$ 和 $c_3$ 

输出：解密后的明文消息 $m$ 

从 $c_1$ 中解析出公钥坐标 $(x_1, y_1)$。 

验证公钥坐标是否在椭圆曲线上。

计算椭圆曲线上的点 $(x_2, y_2) = d_a \cdot (x_1, y_1)$ 。

将 $(x_2, y_2)$ 转换为二进制字符串 $x_{2bin}$ 和 $y_{2bin}$ 。

调用KDF函数，从 $(x_{2bin}+ y_{2bin})$ 生成一个长度为 $4\cdot |c_2|$ (其中 $|c_2|$ 表示 $c_2$ 的长度) 的二进制字符串 $t$ 。

将密文 $c_2$ 与 $t$ 进行异或运算，得到二进制字符串 $m_{bin}$ 。

计算密文的认证标签 $u = Hash(x_{2bin} + m_{bin} + y_{2bin})$ 。

验证 $c_3$ 是否等于 $u$ 。

将 $m_{bin}$ 转换为十六进制字符串，再将其转换为明文消息 $m$ 。

返回明文消息 $m$ 。

其中， $d_a$ 为私钥， $G$ 为椭圆曲线上的基点， $a$ 、 $b$ 和 $p$ 为椭圆曲线的参数。

# 实现效果
### SM2加密
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/SM2_Enc.jpg">
</div>

### SM2签名
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/SM2_Sign.png">
</div>


 # <center>  Project12 </center>


 # <center>  Project13 </center>
# 实现方式
ECMH(Elliptic curve MultiSet Hash)是一种哈希函数，它的特点是可以把多个数据的 hash 合并到一个 hash 中，还可以支持删除。该哈希函数的基本思想是将集合或多重集合中的每个元素映射到椭圆曲线上的一个点。  
$$hash({a}) + hash({b}) = hash({a,b})$$
哈希函数满足两个多重集合的哈希值之和等于它们的并集的哈希值。空集的哈希值是椭圆曲线上的无穷远点。  
要向多重集合添加一个元素，需要计算该元素的哈希值，并将相应的椭圆曲线上的点加到现有的哈希值上。同样，要从多重集合中删除元素，需要计算该元素的哈希值，并从现有的哈希值中减去相应的椭圆曲线上的点。多重集合中元素的顺序不重要，重复元素是可能的，会导致不同的摘要值。  
更新多重集合的摘要值只需要计算旧的和新的多重集合之间的差异，从而实现了在分布式系统中快速同步节点的方法。  
**以下是对几个函数的说明：**  
`Legendre_symbol(a, p)`：该函数使用欧拉准则计算a和p的勒让德符号，以确定a是否对模p为二次剩余。如果a是二次剩余，则返回1，如果不是，则返回-1，如果a可被p整除，则返回0。  

`modular_sqrt(a, p)`：该函数使用 $Tonelli-Shanks$ 算法计算a模p的模平方根， $Tonelli-Shanks$ 算法是一种用于在质数模下找到平方根的方法。如果a在模p下不是二次剩余，则返回None。

`elliptic_curve_hash(u)`：该函数接受一个输入u，并通过查找距离从u计算的哈希值最近的曲线上的点(x，y)来计算椭圆曲线哈希。该函数使用暴力搜索可能的x值来找到二次剩余d，使得 $y^2 = d$ 在模p下有解。如果存在这样的解，则函数返回点 $(x，y)$ 。否则，返回None。 

`elliptic_curve_hash_set(s)`：该函数接受一个输入集合s，并计算其相应椭圆曲线哈希的总和。它通过迭代s的元素，对每个元素调用`elliptic_curve_hash`函数，并将生成的点(x，y)分别进行组件相加。该函数将结果的总和作为列表 $[x_sum，y_sum]$ 返回。


# 实现效果
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/ECMH.png">
</div>


 # <center>  Project14 </center>
# 实现方式 
PGP是一个加密软件套件，使用混合加密方法以保护数据的机密性、完整性和认证性。它首先使用非对称加密算法（SM2）生成一对公钥和私钥，然后使用对称加密算法（SM4）生成一个临时会话密钥。具体过程如下：

首先，使用非对称加密算法（如SM2）生成一对公钥和私钥。公钥可以公开发布，任何人都可以使用公钥来加密数据，但只有私钥的持有者才能解密数据。  
然后，使用SM2密钥交换算法生成一个临时会话密钥，该会话密钥将用于加密要传输的数据。  
接下来，使用公钥加密临时会话密钥，将加密后的会话密钥和使用对称加密算法加密后的数据一起发送给接收者。  
接收者使用私钥解密会话密钥，然后使用会话密钥解密数据。  

这种混合加密方法结合了非对称加密算法和对称加密算法的优势，可以实现更高效的加密和解密过程，同时保证数据的机密性和完整性。
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/PGP.png">
</div>

在具体代码中，定义了一个generate_key函数，用于生成随机的16字节（128位）会话密钥。  
```python
def generate_key():
    key = secrets.token_bytes(16)
    return key.hex()
```
调用generate_key函数生成一个随机的会话密钥，并使用SM4算法对明文进行加密，得到密文。  
```python
key = generate_key().encode()
crysm4 = sm4.CryptSM4()
crysm4.set_key(key, sm4.SM4_ENCRYPT)
plaintext = 'Liujiaming'
ciphertext = crysm4.crypt_ecb(plaintext.encode())
```
使用SM2算法对会话密钥进行加密，得到加密后的会话密钥。
```python
sm2crypt = sm2.CryptSM2(public_key=public_key, private_key=private_key)
enckey = sm2crypt.encrypt(key)
```
使用SM2算法对加密后的会话密钥进行解密，得到原始的会话密钥。  
```python 
deckey = sm2crypt.decrypt(enckey)
```
使用原始的会话密钥对密文进行解密，得到明文。
```python 
crysm42 = sm4.CryptSM4()
crysm42.set_key(deckey, sm4.SM4_DECRYPT)
dectext = crysm42.crypt_ecb(ciphertext)
```

# 实现效果

<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/SM2_PGP.jpg">
</div>

 # <center>  Project15 </center>
# 实现方式

<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/SM21.png">
</div>

**服务端 A 实现过程：**  
- 生成待签名数据 Z 和 M。  
- 创建 CryptSM2 类的一个实例。  
- 等待来自客户端的连接请求。  
- 接收客户端发送的 P1，并使用 CryptSM2 实例生成 P。  
- 将 P 发送回客户端。  
- 接收客户端发送的 Q1 和 e，并使用 CryptSM2 实例计算 r、s2 和 s3。  
- 将 r、s2 和 s3 发送回客户端。  
- 接收客户端发送的签名值 sig 和 d1。  
- 使用 d1 计算私钥，并使用计算出的私钥和接收到的签名值进行验证。  
- 关闭连接。

**客户端 B 实现过程：**  
- 导入 socket 和 CryptSM2 模块，以及 gmssl 库中的 sm3 和 func 函数。  
- 创建一个 CryptSM2 类的对象 sm2_crypt，用于进行 SM2 加密和签名操作。  
- 建立与服务器的连接，使用 socket 模块的 socket 函数创建一个套接字对象 client_socket，并使用 connect 方法连接服务器。  
- 使用 CryptSM2 实例的 genrateP1 方法生成随机数 P1，并将其发送给服务器。  
- 接收服务器发送的 P，并使用 CryptSM2 实例生成公私钥对。  
- 生成待签名数据 Z 和 M。  
- 使用 CryptSM2 实例的 get_e 和 get_Q1 方法计算 e 和 Q1，并将它们发送给服务器。  
- 接收服务器发送的 r、s2 和 s3，并根据其计算出签名值 sig。  
- 将签名值发送给服务器，并发送私钥 d1。  
- 关闭连接。


# 实现效果
**服务端 A**  
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/SM2_Sign_2P_A.png">
</div>

**客户端 B**
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/SM2_Sign_2P_B.png">
</div>


 # <center>  Project16 </center>


 # <center>  Project17 </center>
# 比较Firefox和谷歌的记住密码插件的实现区别
## 谷歌记住密码插件
- 记住的密码不会因为修改表单属性而消失，即使其他同域名下的表单属性发生改变，记住的密码依然会显示。
- 在显示表单数据时，按照先name后id的规则显示，同name或同id的input先取相同name的记住值，后取相同id的记住值。  
如被记住的input为
```
<input type="text" name="user1" id="user1" >
<input type="text" name="user2" id="user2" >
```
现其他页面有input如下：
```
<input type="text" name="user1" id="user2" > //显示的是上面第一个，既name 为 user1， id 为user1 的input记住值
<input type="text" name="user2" id="user1" > //显示的是上面第二个，既name 为 user2， id 为user2 的input记住值
```

- 对于type=password的input，Chrome不会弹出记住密码的弹窗，只有在跳转的下一个页面有password的input时才会自动填充密码。输入框内容是共享的，不受name和id的影响。
- type=password的DOM上面最近的input默认被Chrome认为是password的用户名，记住密码的原理是按照域名+user+password的形式记住的。
- 即使主表单是被记住的，如果主表单没有name或id，后期依然不能显示，但被记住的密码在其他同站点下表单同类型的input会显示。
如 主表单 index.html 即便只有user 没有name 和id ，password框有name，也会如此
```
<input type="text" placeholder="user"> //记住后不显示
<input type="Password" name="psd" placeholder="Password"> //记住后不显示
```

附表单 password.html
```
<input type="password" name="passworpooo" id="r" class="form-control" placeholder="456446">//记住后显示
```

- 每次修改代码需要清空所有缓存及记住的密码，否则会出现修改了代码但依然显示记住的密码的情况。
- 类型不同但name或id相同的表单域也会显示记住的值，例如email类型的输入框实际上可能是text类型，在自动填充时会按照name或id的匹配来填充值。
如：主表单 index.html
```
<input type="email" name="user" placeholder="Email">
<input type="text" name="user1231" placeholder="user">
<input type="Password" name="psw1231" placeholder="Password">
```
附表单 email.html
```
<input type="text" name="user"> //显示
<input type="email" name="user" id="Email2">//显示
<input type="email" id="user">//显示
```
当主表单被记住后， email.html 中第一个input双击后，依然显示了主表单记住的内容
- 记住密码不同于其他输入域的自动填充，没有弹窗选择记住密码，而是自动记住并隐藏，不会显示在表单中。

  
## Firefox记住密码插件
Firefox 通过`form.elements[n].type == "password"`（遍历所有表单元素）来检测密码，然后通过在表单元素中向后搜索密码字段之前的文本字段来检测用户名字段。  
登录表单必须是 a 的一部分，设置`id="password"`密码字段可能也不会造成什么影响。
#### 密码管理器的工作原理
密码管理器的主要功能是保存和填写用户的登录信息，以便用户在访问网站时能够快速登录。但是，由于不同网站的表单和URL可能存在差异，密码管理器需要猜测填写或保存用户名和密码的方法。
#### 填写登录信息
密码管理器会遍历页面上的每个表单元素，查找用户名和密码，并尽可能地匹配保存的登录信息。为了确定用户名和密码，密码管理器搜索第一个输入字段作为用户名，搜索第一个类型为"password"的输入字段作为密码。HTML5新增了一些输入类型，如`"type=email"`，因此密码管理器也会查找这些类型的字段作为用户名。
#### 保存登录信息
密码管理器会监视表单提交事件，并确定表单中的用户名和密码。如果用户名是新的，则会询问用户是否要保存该新登录信息。如果用户名已存在，但密码不同，则会询问用户是否要更改已保存的密码。如果用户名和密码已经保存，则不需要做任何操作。但是，由于表单可能具有不同的字段顺序和输入类型，密码管理器还需要考虑如何确定哪些字段表示用户名和密码。
#### 处理URL差异
不同网站的URL可能会导致填充或保存失败，因此密码管理器还需要处理URL的差异。例如，密码管理器会根据URL的协议来决定是否填充或保存登录信息。如果一个网站同时提供HTTP和HTTPS访问，那么密码管理器会将它们视为两个不同的网站，并分别保存登录信息。此外，密码管理器还会使用表单的action URL来确定登录信息的保存位置。
总之，Firefox密码管理器通过不断尝试和调整，以尽可能适应各种情况，并提供方便的登录信息管理功能。


# 参考链接
https://support.mozilla.org/zh-CN/kb/password-manager-remember-delete-change-passwords  
https://stackoverflow.com/questions/2398763/how-does-browser-know-when-to-prompt-user-to-save-password
https://segmentfault.com/a/1190000006914652


 # <center>  Project18 </center>
# 实现方式
代码使用 Python 编写，功能是通过Blockstream.info的API获取Bitcoin（比特币）交易信息，并解析交易数据。  
首先，定义了一个比特币交易的哈希值 tx_hash，用于指定要获取的交易信息。接下来，使用 requests 库向 Blockstream.info 的API发送HTTP GET请求，获取指定哈希值对应的比特币交易信息。  
将获取到的数据写入到名为 bitcoin.txt 的文件中，然后再读取该文件的内容。这个步骤是为了避免反复发送请求，也可以避免可能的网络问题。  
然后将获取到的JSON格式的交易信息解析为Python字典 tx_data。  
最后，打印交易信息。

# 实现效果
<div align="center">
  <img src="https://github.com/Ljm200301/ljm/blob/main/pictures/send_a_tx.png">
</div>


 # <center>  Project19 </center>


 # <center>  Project21 </center>


 # <center>  Project22 </center>

